<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta
      name="description"
      content="Retrieve your one-time secret securely with Hakanai - zero-knowledge secret sharing"
    />
    <meta
      http-equiv="Content-Security-Policy"
      content="default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; font-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'; frame-ancestors 'none'; upgrade-insecure-requests"
    />
    <link rel="icon" type="image/svg+xml" href="/icon.svg" />
    <title>Hakanai - Retrieve Secret</title>
    <link rel="stylesheet" href="/style.css" />
  </head>
  <body>
    <main class="container">
      <header class="header">
        <img src="/logo.svg" alt="Logo" width="200" height="60" />
      </header>
      <section aria-labelledby="main-heading">
        <h1 id="main-heading">One Time Secret Retrieval</h1>
        <form onsubmit="event.preventDefault(); retrieveSecret();" novalidate>
          <div class="input-group">
            <label for="secretUrl">Enter URL:</label>
            <input
              type="text"
              id="secretUrl"
              placeholder=""
              aria-describedby="url-help"
              required
              autocomplete="off"
              spellcheck="false"
            />
            <span id="url-help" class="sr-only"
              >Enter the full URL including the secret key after the hash</span
            >
          </div>
          <button type="submit" id="retrieveBtn">Retrieve Secret</button>
        </form>
        <div class="loading" id="loading" role="status" aria-live="polite">
          <div class="spinner" aria-hidden="true"></div>
          <span>Retrieving secret...</span>
        </div>
        <div
          id="result"
          role="region"
          aria-live="polite"
          aria-atomic="true"
        ></div>
      </section>
      <footer class="footer">
        <a
          href="https://github.com/czerwonk/hakanai"
          target="_blank"
          rel="noopener noreferrer"
          >View on GitHub</a
        >
      </footer>
    </main>
    <noscript>
      <div class="container">
        <div class="result error">
          <h3>JavaScript Required</h3>
          <p>
            This application requires JavaScript to decrypt secrets securely in
            your browser.
          </p>
        </div>
      </div>
    </noscript>

    <script src="/scripts/hakanai-client.js"></script>
    <script>
      const UI_STRINGS = {
        EMPTY_URL: "Please enter a valid secret URL",
        INVALID_URL:
          "Invalid URL format. Please include the full URL with the secret key after #",
        RETRIEVE_FAILED: "Failed to retrieve secret",
        SUCCESS_TITLE: "Secret Retrieved Successfully",
        ERROR_TITLE: "Error",
        COPY_TEXT: "Copy",
        COPIED_TEXT: "Copied!",
        COPY_FAILED: "Failed to copy. Please select and copy manually.",
        DOWNLOAD_TEXT: "Download",
        NOTE_TEXT:
          "Note: This secret has been deleted from the server and cannot be accessed again.",
      };

      const TIMEOUTS = {
        COPY_FEEDBACK: 2000,
        DEBOUNCE: 300,
      };

      // Extract base URL from current location or use a default
      const baseUrl = window.location.origin.includes("file://")
        ? "http://localhost:8080"
        : window.location.origin;

      const client = new HakanaiClient(baseUrl);

      // Debouncing helper
      let submitTimeout;
      function debounce(func, wait) {
        return function executedFunction(...args) {
          const later = () => {
            clearTimeout(submitTimeout);
            func(...args);
          };
          clearTimeout(submitTimeout);
          submitTimeout = setTimeout(later, wait);
        };
      }

      const retrieveSecretDebounced = debounce(async function retrieveSecret() {
        const urlInput = document.getElementById("secretUrl");
        const resultDiv = document.getElementById("result");
        const loadingDiv = document.getElementById("loading");
        const button = document.getElementById("retrieveBtn");

        const url = urlInput.value.trim();

        if (!url) {
          showError(UI_STRINGS.EMPTY_URL);
          urlInput.focus();
          return;
        }

        let urlObj;
        let processedUrl = url;

        if (!url.match(/^[a-zA-Z][a-zA-Z0-9+.-]*:\/\//)) {
          // If URL doesn't start with a scheme, prepend the current location's scheme
          const currentScheme = window.location.protocol;
          processedUrl = currentScheme + "//" + url;
        }

        try {
          urlObj = new URL(processedUrl);
          if (!urlObj.hash || urlObj.hash.length <= 1) {
            throw new Error("Missing hash");
          }
        } catch (e) {
          showError(UI_STRINGS.INVALID_URL);
          urlInput.focus();
          return;
        }

        // Show loading state
        loadingDiv.style.display = "block";
        button.disabled = true;
        urlInput.disabled = true;
        resultDiv.innerHTML = "";

        try {
          const secret = await client.receiveSecret(processedUrl);

          showSuccess(secret);

          // Clear the input
          urlInput.value = "";
        } catch (error) {
          showError(error.message || UI_STRINGS.RETRIEVE_FAILED);
        } finally {
          loadingDiv.style.display = "none";
          button.disabled = false;
          urlInput.disabled = false;
        }
      }, TIMEOUTS.DEBOUNCE);

      async function retrieveSecret() {
        retrieveSecretDebounced();
      }

      function showSuccess(secret) {
        const resultDiv = document.getElementById("result");
        resultDiv.className = "result success";
        const secretId = "secret-" + Date.now();

        resultDiv.innerHTML = "";

        // Create elements programmatically to avoid XSS
        const title = document.createElement("h3");
        title.textContent = UI_STRINGS.SUCCESS_TITLE;
        resultDiv.appendChild(title);

        const container = document.createElement("div");
        container.className = "secret-container";

        const textarea = document.createElement("textarea");
        textarea.id = secretId;
        textarea.className = "secret-display";
        textarea.readOnly = true;
        textarea.setAttribute("aria-label", "Retrieved secret content");
        textarea.value = secret;
        textarea.addEventListener("click", function () {
          this.select();
        });
        container.appendChild(textarea);

        const buttonsContainer = document.createElement("div");
        buttonsContainer.className = "buttons-container";

        const copyBtn = document.createElement("button");
        copyBtn.className = "copy-button";
        copyBtn.type = "button";
        copyBtn.textContent = UI_STRINGS.COPY_TEXT;
        copyBtn.setAttribute("aria-label", "Copy secret to clipboard");
        copyBtn.addEventListener("click", function () {
          copySecret(secretId, this);
        });
        buttonsContainer.appendChild(copyBtn);

        const downloadBtn = document.createElement("button");
        downloadBtn.className = "download-button";
        downloadBtn.type = "button";
        downloadBtn.textContent = UI_STRINGS.DOWNLOAD_TEXT;
        downloadBtn.setAttribute("aria-label", "Download secret as text file");
        downloadBtn.addEventListener("click", function () {
          downloadSecret(secret);
        });
        buttonsContainer.appendChild(downloadBtn);

        container.appendChild(buttonsContainer);

        resultDiv.appendChild(container);

        const note = document.createElement("p");
        note.style.marginTop = "var(--spacing-sm, 0.75rem)";
        note.style.fontSize = "0.875rem";
        note.style.color = "var(--color-text-muted, #888888)";

        // Create strong element for "Note:" text
        const strong = document.createElement("strong");
        strong.textContent = "Note:";
        note.appendChild(strong);

        // Add the rest of the text
        note.appendChild(
          document.createTextNode(
            " This secret has been deleted from the server and cannot be accessed again.",
          ),
        );
        resultDiv.appendChild(note);

        announceToScreenReader(UI_STRINGS.SUCCESS_TITLE);
      }

      function showError(message) {
        const resultDiv = document.getElementById("result");
        resultDiv.className = "result error";

        // Clear existing content
        resultDiv.innerHTML = "";

        // Create elements programmatically to avoid XSS
        const title = document.createElement("h3");
        title.textContent = UI_STRINGS.ERROR_TITLE;
        resultDiv.appendChild(title);

        const errorDiv = document.createElement("div");
        errorDiv.textContent = message;
        resultDiv.appendChild(errorDiv);

        announceToScreenReader(`${UI_STRINGS.ERROR_TITLE}: ${message}`);
      }

      function copySecret(secretId, button) {
        const secretElement = document.getElementById(secretId);
        const originalText = button.textContent;

        const secretText = secretElement.value;

        if (navigator.clipboard && navigator.clipboard.writeText) {
          // Modern clipboard API
          navigator.clipboard
            .writeText(secretText)
            .then(() => {
              button.textContent = UI_STRINGS.COPIED_TEXT;
              button.classList.add("copied");
              announceToScreenReader(UI_STRINGS.COPIED_TEXT);
              setTimeout(() => {
                button.textContent = originalText;
                button.classList.remove("copied");
              }, TIMEOUTS.COPY_FEEDBACK);
            })
            .catch((err) => {
              // Fallback to older method
              fallbackCopy(secretText, button, originalText);
            });
        } else {
          // Fallback for older browsers
          fallbackCopy(secretText, button, originalText);
        }
      }

      function fallbackCopy(text, button, originalText) {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
          button.textContent = UI_STRINGS.COPIED_TEXT;
          button.classList.add("copied");
          announceToScreenReader(UI_STRINGS.COPIED_TEXT);
          setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove("copied");
          }, TIMEOUTS.COPY_FEEDBACK);
        } catch (err) {
          alert(UI_STRINGS.COPY_FAILED);
        }

        document.body.removeChild(textArea);
      }

      function downloadSecret(secret) {
        // Create a blob from the secret text
        const blob = new Blob([secret], { type: "text/plain;charset=utf-8" });

        // Create a temporary URL for the blob
        const url = window.URL.createObjectURL(blob);

        // Create a temporary anchor element and trigger download
        const a = document.createElement("a");
        a.style.display = "none";
        a.href = url;
        a.download = `hakanai-secret-${new Date().toISOString().replace(/[:.]/g, "-")}.txt`;

        document.body.appendChild(a);
        a.click();

        // Clean up
        setTimeout(() => {
          document.body.removeChild(a);
          window.URL.revokeObjectURL(url);
        }, 100);

        announceToScreenReader("Secret downloaded as text file");
      }

      const urlInput = document.getElementById("secretUrl");
      urlInput.placeholder = `${baseUrl}/s/uuid#key`;

      // Check if current URL is a short link and prefill the input
      if (window.location.pathname.match(/^\/s\/[^\/]+$/)) {
        urlInput.value = window.location.href;
      }

      // Accessibility helper
      function announceToScreenReader(message) {
        const announcement = document.createElement("div");
        announcement.setAttribute("role", "status");
        announcement.setAttribute("aria-live", "polite");
        announcement.className = "sr-only";
        announcement.textContent = message;
        document.body.appendChild(announcement);

        // Remove after announcement
        setTimeout(() => {
          document.body.removeChild(announcement);
        }, 1000);
      }

      // Add screen reader only styles
      const style = document.createElement("style");
      style.textContent = `
        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border: 0;
        }
      `;
      document.head.appendChild(style);
    </script>
  </body>
</html>
